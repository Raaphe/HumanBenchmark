/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AbstractJsonSchemaPropertyObject
 */
export interface AbstractJsonSchemaPropertyObject {
    /**
     * 
     * @type {string}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'readOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface CollectionModelDevice
 */
export interface CollectionModelDevice {
    /**
     * 
     * @type {CollectionModelDeviceEmbedded}
     * @memberof CollectionModelDevice
     */
    '_embedded'?: CollectionModelDeviceEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelDevice
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelDeviceEmbedded
 */
export interface CollectionModelDeviceEmbedded {
    /**
     * 
     * @type {Array<DeviceResponse>}
     * @memberof CollectionModelDeviceEmbedded
     */
    'devices'?: Array<DeviceResponse>;
}
/**
 * 
 * @export
 * @interface CollectionModelObject
 */
export interface CollectionModelObject {
    /**
     * 
     * @type {CollectionModelObjectEmbedded}
     * @memberof CollectionModelObject
     */
    '_embedded'?: CollectionModelObjectEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelObjectEmbedded
 */
export interface CollectionModelObjectEmbedded {
    /**
     * 
     * @type {Array<object>}
     * @memberof CollectionModelObjectEmbedded
     */
    'objects'?: Array<object>;
}
/**
 * 
 * @export
 * @interface DeviceRequestBody
 */
export interface DeviceRequestBody {
    /**
     * 
     * @type {number}
     * @memberof DeviceRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequestBody
     */
    'userName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceRequestBody
     */
    'donePlaying'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeviceRequestBody
     */
    'score'?: number;
}
/**
 * 
 * @export
 * @interface DeviceResponse
 */
export interface DeviceResponse {
    /**
     * 
     * @type {string}
     * @memberof DeviceResponse
     */
    'userName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceResponse
     */
    'donePlaying'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeviceResponse
     */
    'score'?: number;
}
/**
 * 
 * @export
 * @interface EntityModelDevice
 */
export interface EntityModelDevice {
    /**
     * 
     * @type {string}
     * @memberof EntityModelDevice
     */
    'userName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelDevice
     */
    'donePlaying'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EntityModelDevice
     */
    'score'?: number;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelDevice
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelGame
 */
export interface EntityModelGame {
    /**
     * 
     * @type {string}
     * @memberof EntityModelGame
     */
    'gameName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelGame
     */
    'gameDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelGame
     */
    'gameType'?: EntityModelGameGameTypeEnum;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelGame
     */
    '_links'?: { [key: string]: Link; };
}

export const EntityModelGameGameTypeEnum = {
    ChimpGame: 'CHIMP_GAME',
    VisualMemoryGame: 'VISUAL_MEMORY_GAME',
    VerbalMemoryGame: 'VERBAL_MEMORY_GAME',
    DigitMemoryGame: 'DIGIT_MEMORY_GAME'
} as const;

export type EntityModelGameGameTypeEnum = typeof EntityModelGameGameTypeEnum[keyof typeof EntityModelGameGameTypeEnum];

/**
 * 
 * @export
 * @interface EntityModelSession
 */
export interface EntityModelSession {
    /**
     * 
     * @type {string}
     * @memberof EntityModelSession
     */
    'sessionCode'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityModelSession
     */
    'gameCompleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelSession
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface GameRequestBody
 */
export interface GameRequestBody {
    /**
     * 
     * @type {number}
     * @memberof GameRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GameRequestBody
     */
    'gameName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GameRequestBody
     */
    'gameDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof GameRequestBody
     */
    'gameType'?: GameRequestBodyGameTypeEnum;
}

export const GameRequestBodyGameTypeEnum = {
    ChimpGame: 'CHIMP_GAME',
    VisualMemoryGame: 'VISUAL_MEMORY_GAME',
    VerbalMemoryGame: 'VERBAL_MEMORY_GAME',
    DigitMemoryGame: 'DIGIT_MEMORY_GAME'
} as const;

export type GameRequestBodyGameTypeEnum = typeof GameRequestBodyGameTypeEnum[keyof typeof GameRequestBodyGameTypeEnum];

/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof Item
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Item
     */
    'requiredProperties'?: Array<string>;
}
/**
 * 
 * @export
 * @interface JsonSchema
 */
export interface JsonSchema {
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof JsonSchema
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof JsonSchema
     */
    'requiredProperties'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Item; }}
     * @memberof JsonSchema
     */
    'definitions'?: { [key: string]: Item; };
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    '$schema'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'hreflang'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'deprecation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    'templated'?: boolean;
}
/**
 * 
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelDevice
 */
export interface PagedModelEntityModelDevice {
    /**
     * 
     * @type {PagedModelEntityModelDeviceEmbedded}
     * @memberof PagedModelEntityModelDevice
     */
    '_embedded'?: PagedModelEntityModelDeviceEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelDevice
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelDevice
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelDeviceEmbedded
 */
export interface PagedModelEntityModelDeviceEmbedded {
    /**
     * 
     * @type {Array<EntityModelDevice>}
     * @memberof PagedModelEntityModelDeviceEmbedded
     */
    'devices'?: Array<EntityModelDevice>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelGame
 */
export interface PagedModelEntityModelGame {
    /**
     * 
     * @type {PagedModelEntityModelGameEmbedded}
     * @memberof PagedModelEntityModelGame
     */
    '_embedded'?: PagedModelEntityModelGameEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelGame
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelGame
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelGameEmbedded
 */
export interface PagedModelEntityModelGameEmbedded {
    /**
     * 
     * @type {Array<EntityModelGame>}
     * @memberof PagedModelEntityModelGameEmbedded
     */
    'games'?: Array<EntityModelGame>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelSession
 */
export interface PagedModelEntityModelSession {
    /**
     * 
     * @type {PagedModelEntityModelSessionEmbedded}
     * @memberof PagedModelEntityModelSession
     */
    '_embedded'?: PagedModelEntityModelSessionEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelSession
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelSession
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelSessionEmbedded
 */
export interface PagedModelEntityModelSessionEmbedded {
    /**
     * 
     * @type {Array<EntityModelSession>}
     * @memberof PagedModelEntityModelSessionEmbedded
     */
    'sessions'?: Array<EntityModelSession>;
}
/**
 * 
 * @export
 * @interface RepresentationModelObject
 */
export interface RepresentationModelObject {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof RepresentationModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface SessionRequestBody
 */
export interface SessionRequestBody {
    /**
     * 
     * @type {number}
     * @memberof SessionRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionRequestBody
     */
    'sessionCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionRequestBody
     */
    'players'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SessionRequestBody
     */
    'gameCompleted'?: boolean;
}

/**
 * DeviceEntityControllerApi - axios parameter creator
 * @export
 */
export const DeviceEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-device
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceDeviceDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceDeviceDelete', 'id', id)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-device
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceDeviceGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-device
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceDeviceGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceDeviceGet', 'id', id)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-device
         * @param {string} id 
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceDevicePatch: async (id: string, deviceRequestBody: DeviceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceDevicePatch', 'id', id)
            // verify required parameter 'deviceRequestBody' is not null or undefined
            assertParamExists('patchItemResourceDevicePatch', 'deviceRequestBody', deviceRequestBody)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-device
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceDevicePost: async (deviceRequestBody: DeviceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceDevicePost', 'deviceRequestBody', deviceRequestBody)
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-device
         * @param {string} id 
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceDevicePut: async (id: string, deviceRequestBody: DeviceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceDevicePut', 'id', id)
            // verify required parameter 'deviceRequestBody' is not null or undefined
            assertParamExists('putItemResourceDevicePut', 'deviceRequestBody', deviceRequestBody)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceEntityControllerApi - functional programming interface
 * @export
 */
export const DeviceEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-device
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceDeviceDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceDeviceDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeviceEntityControllerApi.deleteItemResourceDeviceDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-device
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceDeviceGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceDeviceGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeviceEntityControllerApi.getCollectionResourceDeviceGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-device
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceDeviceGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceDeviceGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeviceEntityControllerApi.getItemResourceDeviceGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-device
         * @param {string} id 
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceDevicePatch(id: string, deviceRequestBody: DeviceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceDevicePatch(id, deviceRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeviceEntityControllerApi.patchItemResourceDevicePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-device
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceDevicePost(deviceRequestBody: DeviceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceDevicePost(deviceRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeviceEntityControllerApi.postCollectionResourceDevicePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-device
         * @param {string} id 
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceDevicePut(id: string, deviceRequestBody: DeviceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceDevicePut(id, deviceRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeviceEntityControllerApi.putItemResourceDevicePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DeviceEntityControllerApi - factory interface
 * @export
 */
export const DeviceEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceEntityControllerApiFp(configuration)
    return {
        /**
         * delete-device
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceDeviceDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceDeviceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-device
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceDeviceGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelDevice> {
            return localVarFp.getCollectionResourceDeviceGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-device
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceDeviceGet(id: string, options?: any): AxiosPromise<EntityModelDevice> {
            return localVarFp.getItemResourceDeviceGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-device
         * @param {string} id 
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceDevicePatch(id: string, deviceRequestBody: DeviceRequestBody, options?: any): AxiosPromise<EntityModelDevice> {
            return localVarFp.patchItemResourceDevicePatch(id, deviceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-device
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceDevicePost(deviceRequestBody: DeviceRequestBody, options?: any): AxiosPromise<EntityModelDevice> {
            return localVarFp.postCollectionResourceDevicePost(deviceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-device
         * @param {string} id 
         * @param {DeviceRequestBody} deviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceDevicePut(id: string, deviceRequestBody: DeviceRequestBody, options?: any): AxiosPromise<EntityModelDevice> {
            return localVarFp.putItemResourceDevicePut(id, deviceRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceEntityControllerApi - object-oriented interface
 * @export
 * @class DeviceEntityControllerApi
 * @extends {BaseAPI}
 */
export class DeviceEntityControllerApi extends BaseAPI {
    /**
     * delete-device
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEntityControllerApi
     */
    public deleteItemResourceDeviceDelete(id: string, options?: RawAxiosRequestConfig) {
        return DeviceEntityControllerApiFp(this.configuration).deleteItemResourceDeviceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-device
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEntityControllerApi
     */
    public getCollectionResourceDeviceGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return DeviceEntityControllerApiFp(this.configuration).getCollectionResourceDeviceGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-device
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEntityControllerApi
     */
    public getItemResourceDeviceGet(id: string, options?: RawAxiosRequestConfig) {
        return DeviceEntityControllerApiFp(this.configuration).getItemResourceDeviceGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-device
     * @param {string} id 
     * @param {DeviceRequestBody} deviceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEntityControllerApi
     */
    public patchItemResourceDevicePatch(id: string, deviceRequestBody: DeviceRequestBody, options?: RawAxiosRequestConfig) {
        return DeviceEntityControllerApiFp(this.configuration).patchItemResourceDevicePatch(id, deviceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-device
     * @param {DeviceRequestBody} deviceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEntityControllerApi
     */
    public postCollectionResourceDevicePost(deviceRequestBody: DeviceRequestBody, options?: RawAxiosRequestConfig) {
        return DeviceEntityControllerApiFp(this.configuration).postCollectionResourceDevicePost(deviceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-device
     * @param {string} id 
     * @param {DeviceRequestBody} deviceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEntityControllerApi
     */
    public putItemResourceDevicePut(id: string, deviceRequestBody: DeviceRequestBody, options?: RawAxiosRequestConfig) {
        return DeviceEntityControllerApiFp(this.configuration).putItemResourceDevicePut(id, deviceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeviceSearchControllerApi - axios parameter creator
 * @export
 */
export const DeviceSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchDeviceGet: async (username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices/search/getDeviceByUserName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceSearchControllerApi - functional programming interface
 * @export
 */
export const DeviceSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchDeviceGet(username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchDeviceGet(username, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeviceSearchControllerApi.executeSearchDeviceGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DeviceSearchControllerApi - factory interface
 * @export
 */
export const DeviceSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchDeviceGet(username?: string, options?: any): AxiosPromise<EntityModelDevice> {
            return localVarFp.executeSearchDeviceGet(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceSearchControllerApi - object-oriented interface
 * @export
 * @class DeviceSearchControllerApi
 * @extends {BaseAPI}
 */
export class DeviceSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceSearchControllerApi
     */
    public executeSearchDeviceGet(username?: string, options?: RawAxiosRequestConfig) {
        return DeviceSearchControllerApiFp(this.configuration).executeSearchDeviceGet(username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameEntityControllerApi - axios parameter creator
 * @export
 */
export const GameEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-game
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceGameDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceGameDelete', 'id', id)
            const localVarPath = `/games/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-game
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceGameGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-game
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceGameGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceGameGet', 'id', id)
            const localVarPath = `/games/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-game
         * @param {string} id 
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceGamePatch: async (id: string, gameRequestBody: GameRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceGamePatch', 'id', id)
            // verify required parameter 'gameRequestBody' is not null or undefined
            assertParamExists('patchItemResourceGamePatch', 'gameRequestBody', gameRequestBody)
            const localVarPath = `/games/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-game
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceGamePost: async (gameRequestBody: GameRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceGamePost', 'gameRequestBody', gameRequestBody)
            const localVarPath = `/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-game
         * @param {string} id 
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceGamePut: async (id: string, gameRequestBody: GameRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceGamePut', 'id', id)
            // verify required parameter 'gameRequestBody' is not null or undefined
            assertParamExists('putItemResourceGamePut', 'gameRequestBody', gameRequestBody)
            const localVarPath = `/games/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameEntityControllerApi - functional programming interface
 * @export
 */
export const GameEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-game
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceGameDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceGameDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GameEntityControllerApi.deleteItemResourceGameDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-game
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceGameGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelGame>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceGameGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GameEntityControllerApi.getCollectionResourceGameGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-game
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceGameGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelGame>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceGameGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GameEntityControllerApi.getItemResourceGameGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-game
         * @param {string} id 
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceGamePatch(id: string, gameRequestBody: GameRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelGame>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceGamePatch(id, gameRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GameEntityControllerApi.patchItemResourceGamePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-game
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceGamePost(gameRequestBody: GameRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelGame>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceGamePost(gameRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GameEntityControllerApi.postCollectionResourceGamePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-game
         * @param {string} id 
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceGamePut(id: string, gameRequestBody: GameRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelGame>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceGamePut(id, gameRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GameEntityControllerApi.putItemResourceGamePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GameEntityControllerApi - factory interface
 * @export
 */
export const GameEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameEntityControllerApiFp(configuration)
    return {
        /**
         * delete-game
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceGameDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceGameDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-game
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceGameGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelGame> {
            return localVarFp.getCollectionResourceGameGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-game
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceGameGet(id: string, options?: any): AxiosPromise<EntityModelGame> {
            return localVarFp.getItemResourceGameGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-game
         * @param {string} id 
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceGamePatch(id: string, gameRequestBody: GameRequestBody, options?: any): AxiosPromise<EntityModelGame> {
            return localVarFp.patchItemResourceGamePatch(id, gameRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-game
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceGamePost(gameRequestBody: GameRequestBody, options?: any): AxiosPromise<EntityModelGame> {
            return localVarFp.postCollectionResourceGamePost(gameRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-game
         * @param {string} id 
         * @param {GameRequestBody} gameRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceGamePut(id: string, gameRequestBody: GameRequestBody, options?: any): AxiosPromise<EntityModelGame> {
            return localVarFp.putItemResourceGamePut(id, gameRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameEntityControllerApi - object-oriented interface
 * @export
 * @class GameEntityControllerApi
 * @extends {BaseAPI}
 */
export class GameEntityControllerApi extends BaseAPI {
    /**
     * delete-game
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameEntityControllerApi
     */
    public deleteItemResourceGameDelete(id: string, options?: RawAxiosRequestConfig) {
        return GameEntityControllerApiFp(this.configuration).deleteItemResourceGameDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-game
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameEntityControllerApi
     */
    public getCollectionResourceGameGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return GameEntityControllerApiFp(this.configuration).getCollectionResourceGameGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-game
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameEntityControllerApi
     */
    public getItemResourceGameGet(id: string, options?: RawAxiosRequestConfig) {
        return GameEntityControllerApiFp(this.configuration).getItemResourceGameGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-game
     * @param {string} id 
     * @param {GameRequestBody} gameRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameEntityControllerApi
     */
    public patchItemResourceGamePatch(id: string, gameRequestBody: GameRequestBody, options?: RawAxiosRequestConfig) {
        return GameEntityControllerApiFp(this.configuration).patchItemResourceGamePatch(id, gameRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-game
     * @param {GameRequestBody} gameRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameEntityControllerApi
     */
    public postCollectionResourceGamePost(gameRequestBody: GameRequestBody, options?: RawAxiosRequestConfig) {
        return GameEntityControllerApiFp(this.configuration).postCollectionResourceGamePost(gameRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-game
     * @param {string} id 
     * @param {GameRequestBody} gameRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameEntityControllerApi
     */
    public putItemResourceGamePut(id: string, gameRequestBody: GameRequestBody, options?: RawAxiosRequestConfig) {
        return GameEntityControllerApiFp(this.configuration).putItemResourceGamePut(id, gameRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileControllerApi - axios parameter creator
 * @export
 */
export const ProfileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileControllerApi - functional programming interface
 * @export
 */
export const ProfileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor111(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor111(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor111']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor112(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor112(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor112']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor113(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor113(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.descriptor113']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllFormsOfMetadata1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepresentationModelObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllFormsOfMetadata1(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProfileControllerApi.listAllFormsOfMetadata1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProfileControllerApi - factory interface
 * @export
 */
export const ProfileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor111(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor112(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113(options?: any): AxiosPromise<string> {
            return localVarFp.descriptor113(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1(options?: any): AxiosPromise<RepresentationModelObject> {
            return localVarFp.listAllFormsOfMetadata1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileControllerApi - object-oriented interface
 * @export
 * @class ProfileControllerApi
 * @extends {BaseAPI}
 */
export class ProfileControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor111(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor111(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor112(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor112(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor113(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor113(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public listAllFormsOfMetadata1(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).listAllFormsOfMetadata1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionEntityControllerApi - axios parameter creator
 * @export
 */
export const SessionEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceSessionDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceSessionDelete', 'id', id)
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-session
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceSessionGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceSessionGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceSessionGet', 'id', id)
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-session
         * @param {string} id 
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceSessionPatch: async (id: string, sessionRequestBody: SessionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceSessionPatch', 'id', id)
            // verify required parameter 'sessionRequestBody' is not null or undefined
            assertParamExists('patchItemResourceSessionPatch', 'sessionRequestBody', sessionRequestBody)
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-session
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceSessionPost: async (sessionRequestBody: SessionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceSessionPost', 'sessionRequestBody', sessionRequestBody)
            const localVarPath = `/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-session
         * @param {string} id 
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceSessionPut: async (id: string, sessionRequestBody: SessionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceSessionPut', 'id', id)
            // verify required parameter 'sessionRequestBody' is not null or undefined
            assertParamExists('putItemResourceSessionPut', 'sessionRequestBody', sessionRequestBody)
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionEntityControllerApi - functional programming interface
 * @export
 */
export const SessionEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceSessionDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceSessionDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionEntityControllerApi.deleteItemResourceSessionDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-session
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceSessionGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceSessionGet1(page, size, sort, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionEntityControllerApi.getCollectionResourceSessionGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceSessionGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceSessionGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionEntityControllerApi.getItemResourceSessionGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * patch-session
         * @param {string} id 
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceSessionPatch(id: string, sessionRequestBody: SessionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceSessionPatch(id, sessionRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionEntityControllerApi.patchItemResourceSessionPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * create-session
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceSessionPost(sessionRequestBody: SessionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceSessionPost(sessionRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionEntityControllerApi.postCollectionResourceSessionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-session
         * @param {string} id 
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceSessionPut(id: string, sessionRequestBody: SessionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceSessionPut(id, sessionRequestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionEntityControllerApi.putItemResourceSessionPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SessionEntityControllerApi - factory interface
 * @export
 */
export const SessionEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionEntityControllerApiFp(configuration)
    return {
        /**
         * delete-session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceSessionDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemResourceSessionDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-session
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceSessionGet1(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PagedModelEntityModelSession> {
            return localVarFp.getCollectionResourceSessionGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceSessionGet(id: string, options?: any): AxiosPromise<EntityModelSession> {
            return localVarFp.getItemResourceSessionGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-session
         * @param {string} id 
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceSessionPatch(id: string, sessionRequestBody: SessionRequestBody, options?: any): AxiosPromise<EntityModelSession> {
            return localVarFp.patchItemResourceSessionPatch(id, sessionRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-session
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceSessionPost(sessionRequestBody: SessionRequestBody, options?: any): AxiosPromise<EntityModelSession> {
            return localVarFp.postCollectionResourceSessionPost(sessionRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-session
         * @param {string} id 
         * @param {SessionRequestBody} sessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceSessionPut(id: string, sessionRequestBody: SessionRequestBody, options?: any): AxiosPromise<EntityModelSession> {
            return localVarFp.putItemResourceSessionPut(id, sessionRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionEntityControllerApi - object-oriented interface
 * @export
 * @class SessionEntityControllerApi
 * @extends {BaseAPI}
 */
export class SessionEntityControllerApi extends BaseAPI {
    /**
     * delete-session
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionEntityControllerApi
     */
    public deleteItemResourceSessionDelete(id: string, options?: RawAxiosRequestConfig) {
        return SessionEntityControllerApiFp(this.configuration).deleteItemResourceSessionDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-session
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionEntityControllerApi
     */
    public getCollectionResourceSessionGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return SessionEntityControllerApiFp(this.configuration).getCollectionResourceSessionGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-session
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionEntityControllerApi
     */
    public getItemResourceSessionGet(id: string, options?: RawAxiosRequestConfig) {
        return SessionEntityControllerApiFp(this.configuration).getItemResourceSessionGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-session
     * @param {string} id 
     * @param {SessionRequestBody} sessionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionEntityControllerApi
     */
    public patchItemResourceSessionPatch(id: string, sessionRequestBody: SessionRequestBody, options?: RawAxiosRequestConfig) {
        return SessionEntityControllerApiFp(this.configuration).patchItemResourceSessionPatch(id, sessionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-session
     * @param {SessionRequestBody} sessionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionEntityControllerApi
     */
    public postCollectionResourceSessionPost(sessionRequestBody: SessionRequestBody, options?: RawAxiosRequestConfig) {
        return SessionEntityControllerApiFp(this.configuration).postCollectionResourceSessionPost(sessionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-session
     * @param {string} id 
     * @param {SessionRequestBody} sessionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionEntityControllerApi
     */
    public putItemResourceSessionPut(id: string, sessionRequestBody: SessionRequestBody, options?: RawAxiosRequestConfig) {
        return SessionEntityControllerApiFp(this.configuration).putItemResourceSessionPut(id, sessionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const SessionPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-device-by-session-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceSessionPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceSessionPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceSessionPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/sessions/{id}/players`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-device-by-session-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceSessionPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceSessionPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceSessionPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/sessions/{id}/players`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-device-by-session-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdSessionDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdSessionDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdSessionDelete', 'propertyId', propertyId)
            const localVarPath = `/sessions/{id}/players/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-device-by-session-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceSessionDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceSessionDelete', 'id', id)
            const localVarPath = `/sessions/{id}/players`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-device-by-session-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceSessionGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceSessionGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceSessionGet', 'propertyId', propertyId)
            const localVarPath = `/sessions/{id}/players/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-device-by-session-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceSessionGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceSessionGet1', 'id', id)
            const localVarPath = `/sessions/{id}/players`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const SessionPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-device-by-session-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceSessionPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceSessionPatch(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionPropertyReferenceControllerApi.createPropertyReferenceSessionPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * update-device-by-session-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceSessionPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceSessionPut(id, collectionModelObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionPropertyReferenceControllerApi.createPropertyReferenceSessionPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-device-by-session-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdSessionDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdSessionDelete(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionPropertyReferenceControllerApi.deletePropertyReferenceIdSessionDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * delete-device-by-session-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceSessionDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceSessionDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionPropertyReferenceControllerApi.deletePropertyReferenceSessionDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-device-by-session-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceSessionGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceSessionGet(id, propertyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionPropertyReferenceControllerApi.followPropertyReferenceSessionGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get-device-by-session-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceSessionGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceSessionGet1(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionPropertyReferenceControllerApi.followPropertyReferenceSessionGet1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SessionPropertyReferenceControllerApi - factory interface
 * @export
 */
export const SessionPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-device-by-session-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceSessionPatch(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<CollectionModelDevice> {
            return localVarFp.createPropertyReferenceSessionPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-device-by-session-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceSessionPut(id: string, collectionModelObject: CollectionModelObject, options?: any): AxiosPromise<CollectionModelDevice> {
            return localVarFp.createPropertyReferenceSessionPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-device-by-session-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdSessionDelete(id: string, propertyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdSessionDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-device-by-session-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceSessionDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceSessionDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-device-by-session-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceSessionGet(id: string, propertyId: string, options?: any): AxiosPromise<CollectionModelDevice> {
            return localVarFp.followPropertyReferenceSessionGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-device-by-session-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceSessionGet1(id: string, options?: any): AxiosPromise<CollectionModelDevice> {
            return localVarFp.followPropertyReferenceSessionGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class SessionPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class SessionPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-device-by-session-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionPropertyReferenceControllerApi
     */
    public createPropertyReferenceSessionPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return SessionPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceSessionPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-device-by-session-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionPropertyReferenceControllerApi
     */
    public createPropertyReferenceSessionPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return SessionPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceSessionPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-device-by-session-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdSessionDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return SessionPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdSessionDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-device-by-session-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionPropertyReferenceControllerApi
     */
    public deletePropertyReferenceSessionDelete(id: string, options?: RawAxiosRequestConfig) {
        return SessionPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceSessionDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-device-by-session-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionPropertyReferenceControllerApi
     */
    public followPropertyReferenceSessionGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return SessionPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceSessionGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-device-by-session-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionPropertyReferenceControllerApi
     */
    public followPropertyReferenceSessionGet1(id: string, options?: RawAxiosRequestConfig) {
        return SessionPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceSessionGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionSearchControllerApi - axios parameter creator
 * @export
 */
export const SessionSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sessionCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchSessionGet: async (sessionCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sessions/search/getSessionBySessionCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionCode !== undefined) {
                localVarQueryParameter['sessionCode'] = sessionCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionSearchControllerApi - functional programming interface
 * @export
 */
export const SessionSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sessionCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchSessionGet(sessionCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchSessionGet(sessionCode, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionSearchControllerApi.executeSearchSessionGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SessionSearchControllerApi - factory interface
 * @export
 */
export const SessionSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sessionCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchSessionGet(sessionCode?: string, options?: any): AxiosPromise<EntityModelSession> {
            return localVarFp.executeSearchSessionGet(sessionCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionSearchControllerApi - object-oriented interface
 * @export
 * @class SessionSearchControllerApi
 * @extends {BaseAPI}
 */
export class SessionSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [sessionCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionSearchControllerApi
     */
    public executeSearchSessionGet(sessionCode?: string, options?: RawAxiosRequestConfig) {
        return SessionSearchControllerApiFp(this.configuration).executeSearchSessionGet(sessionCode, options).then((request) => request(this.axios, this.basePath));
    }
}



